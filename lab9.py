def heapify(arr, length, i):
    # Инициализируем переменную largest как текущий узел
    largest = i
    
    # Вычисляем индексы левого и правого дочерних узлов
    l = 2 * i + 1  # левый дочерний = 2*i + 1
    r = 2 * i + 2  # правый дочерний = 2*i + 2

    # Проверяем, существует ли левый дочерний узел и больше ли он текущего (родительского) узла
    if l < length and arr[largest] < arr[l]:
        largest = l

    # Проверяем, существует ли правый дочерний узел и больше ли он текущего largest
    if r < length and arr[largest] < arr[r]:
        largest = r

    # Если largest изменился, то нужно поменять элементы местами
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # Обмен значениями

        # Рекурсивно восстанавливаем свойство кучи для поддерева с корнем в largest
        heapify(arr, length, largest)

# Главная функция для сортировки массива с использованием кучи
def heapSort(arr):
    length = len(arr)  # Определяем размер массива

    # Строим максимальную кучу (max-heap)
    # Проходим от последнего родительского узла до корня
    for i in range(length // 2 - 1, -1, -1):
        heapify(arr, length, i)

    # Один за другим извлекаем элементы из кучи
    for i in range(length - 1, 0, -1):
        # Меняем местами корень (максимальный элемент) с последним элементом
        arr[i], arr[0] = arr[0], arr[i]

        # Восстанавливаем свойства кучи для подмассива с исключением последнего элемента
        heapify(arr, i, 0)

# Код для тестирования алгоритма сортировки
arr = [12, 11, 13, 5, 6, 7]
heapSort(arr)  # Вызываем сортировку

# Печатаем отсортированный массив

print("Отсортированный список:", arr)

